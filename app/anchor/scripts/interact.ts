import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Contracts } from "../target/types/contracts";
import {
    createMint,
    getOrCreateAssociatedTokenAccount,
    mintTo,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID,
} from "@solana/spl-token";
import {
    Keypair,
    SystemProgram,
    SYSVAR_RENT_PUBKEY,
    PublicKey,
    Connection,
    clusterApiUrl,
} from "@solana/web3.js";

// Configuration
const NETWORK = "devnet"; // ou "localnet" pour tests locaux
const PROGRAM_ID = "5S3gna7dtmoGD1M6AqRLRZvP7MUDHp8K8pkXRMovsrR9";

class YieldosInteraction {
    private connection: Connection;
    private program: Program<Contracts>;
    private provider: anchor.AnchorProvider;
    private admin: Keypair;
    private user1: Keypair;
    private user2: Keypair;

    // √âtats du protocole
    private underlyingMint: PublicKey | null = null;
    private strategyCounterPda: PublicKey | null = null;
    private strategyPda: PublicKey | null = null;
    private strategyVaultPda: PublicKey | null = null;
    private yieldTokenMintPda: PublicKey | null = null;
    private userPositionPda: PublicKey | null = null;
    private marketplacePda: PublicKey | null = null;
    private marketplaceCounterPda: PublicKey | null = null;

    // Param√®tres
    private readonly strategyId = 0;
    private readonly strategyName = "Yieldos Demo Strategy";
    private readonly strategyApy = 1500; // 15% APY
    private readonly decimals = 6;
    private readonly depositAmount = 1000 * 10 ** this.decimals; // 1000 tokens

    constructor() {
        console.log("üöÄ Initialisation de l'interaction avec Yieldos...");

        // Connexion selon l'environnement
        if (NETWORK === "devnet") {
            this.connection = new Connection(clusterApiUrl("devnet"), "confirmed");
        } else {
            this.connection = new Connection("http://localhost:8899", "confirmed");
        }

        // Configuration du provider
        const wallet = new anchor.Wallet(Keypair.generate()); // Temporaire
        this.provider = new anchor.AnchorProvider(this.connection, wallet, {
            commitment: "confirmed",
        });
        anchor.setProvider(this.provider);

        // Chargement du programme
        const idl = require("../target/idl/contracts.json");
        const programId = new PublicKey(PROGRAM_ID);
        this.program = new Program(idl, this.provider, programId as any);

        // G√©n√©ration des comptes de test
        this.admin = Keypair.generate();
        this.user1 = Keypair.generate();
        this.user2 = Keypair.generate();

        console.log("üìç Program ID:", this.program.programId.toString());
        console.log("üë§ Admin:", this.admin.publicKey.toString());
        console.log("üë§ User1:", this.user1.publicKey.toString());
        console.log("üë§ User2:", this.user2.publicKey.toString());
    }

    async setupAccounts() {
        console.log("\nüí∞ === CONFIGURATION DES COMPTES ===");

        // Airdrop SOL aux comptes de test
        try {
            console.log("üîÑ Airdrop SOL aux comptes...");

            const airdropPromises = [
                this.connection.requestAirdrop(this.admin.publicKey, 5 * anchor.web3.LAMPORTS_PER_SOL),
                this.connection.requestAirdrop(this.user1.publicKey, 5 * anchor.web3.LAMPORTS_PER_SOL),
                this.connection.requestAirdrop(this.user2.publicKey, 3 * anchor.web3.LAMPORTS_PER_SOL),
            ];

            await Promise.all(airdropPromises.map(p => p.then(sig => this.connection.confirmTransaction(sig))));

            console.log("‚úÖ Airdrop termin√©");
        } catch (error) {
            console.log("‚ö†Ô∏è  Limite d'airdrop atteinte, utilisation des fonds existants");
        }

        // Cr√©ation du token de test
        console.log("üîÑ Cr√©ation du token sous-jacent...");
        this.underlyingMint = await createMint(
            this.connection,
            this.admin,
            this.admin.publicKey,
            null,
            this.decimals
        );
        console.log("‚úÖ Token sous-jacent cr√©√©:", this.underlyingMint.toString());

        // Calcul des PDAs
        this.derivePDAs();
    }

    private derivePDAs() {
        console.log("\nüîë === D√âRIVATION DES PDAs ===");

        [this.strategyCounterPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("strategy_counter")],
            this.program.programId
        );
        console.log("üìä Strategy Counter PDA:", this.strategyCounterPda.toString());

        [this.strategyPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("strategy"), new anchor.BN(this.strategyId).toArrayLike(Buffer, "le", 8)],
            this.program.programId
        );
        console.log("üìà Strategy PDA:", this.strategyPda.toString());

        [this.strategyVaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("strategy_vault"), new anchor.BN(this.strategyId).toArrayLike(Buffer, "le", 8)],
            this.program.programId
        );
        console.log("üè¶ Strategy Vault PDA:", this.strategyVaultPda.toString());

        [this.yieldTokenMintPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("yield_token"), new anchor.BN(this.strategyId).toArrayLike(Buffer, "le", 8)],
            this.program.programId
        );
        console.log("ü™ô Yield Token Mint PDA:", this.yieldTokenMintPda.toString());

        [this.userPositionPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("user_position"), this.user1.publicKey.toBuffer(), this.strategyPda.toBuffer()],
            this.program.programId
        );
        console.log("üë§ User Position PDA:", this.userPositionPda.toString());

        [this.marketplacePda] = PublicKey.findProgramAddressSync(
            [Buffer.from("marketplace"), this.strategyPda.toBuffer()],
            this.program.programId
        );
        console.log("üè™ Marketplace PDA:", this.marketplacePda.toString());

        [this.marketplaceCounterPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("marketplace_counter")],
            this.program.programId
        );
        console.log("üìä Marketplace Counter PDA:", this.marketplaceCounterPda.toString());
    }

    async initializeProtocol() {
        console.log("\nüîÑ === INITIALISATION DU PROTOCOLE YIELDOS ===");

        try {
            const tx = await this.program.methods
                .initializeProtocol()
                .accounts({
                    admin: this.admin.publicKey,
                    strategyCounter: this.strategyCounterPda,
                    systemProgram: SystemProgram.programId,
                    rent: SYSVAR_RENT_PUBKEY,
                } as any)
                .signers([this.admin])
                .rpc();

            console.log("‚úÖ Protocole Yieldos initialis√©!");
            console.log("üìù Transaction:", tx);

            // V√©rification
            const counter = await this.program.account.strategyCounter.fetch(this.strategyCounterPda!);
            console.log("üìä Compteur de strat√©gies:", counter.count.toNumber());

        } catch (error: any) {
            if (error.message.includes("already in use")) {
                console.log("‚ÑπÔ∏è  Protocole d√©j√† initialis√©");
            } else {
                console.error("‚ùå Erreur d'initialisation:", error.message);
                throw error;
            }
        }
    }

    async createStrategy() {
        console.log("\nüîÑ === CR√âATION DE STRAT√âGIE YIELDOS ===");

        try {
            const tx = await this.program.methods
                .createStrategy(this.strategyName, this.strategyApy, new anchor.BN(this.strategyId))
                .accounts({
                    admin: this.admin.publicKey,
                    strategy: this.strategyPda,
                    strategyCounter: this.strategyCounterPda,
                    underlyingToken: this.underlyingMint,
                    yieldTokenMint: this.yieldTokenMintPda,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    systemProgram: SystemProgram.programId,
                    rent: SYSVAR_RENT_PUBKEY,
                } as any)
                .signers([this.admin])
                .rpc();

            console.log("‚úÖ Strat√©gie Yieldos cr√©√©e!");
            console.log("üìù Transaction:", tx);

            // V√©rification
            const strategy = await this.program.account.strategy.fetch(this.strategyPda!);
            console.log("üìä D√©tails de la strat√©gie:");
            console.log("   üè∑Ô∏è  Nom:", strategy.name);
            console.log("   üìà APY:", strategy.apy.toNumber() / 100, "%");
            console.log("   ‚úÖ Active:", strategy.isActive);
            console.log("   üí∞ D√©p√¥ts totaux:", strategy.totalDeposits.toNumber() / 10 ** this.decimals);

        } catch (error: any) {
            if (error.message.includes("already in use")) {
                console.log("‚ÑπÔ∏è  Strat√©gie d√©j√† cr√©√©e");
            } else {
                console.error("‚ùå Erreur de cr√©ation:", error.message);
                throw error;
            }
        }
    }

    async setupUserTokens() {
        console.log("\nüîÑ === CONFIGURATION DES TOKENS UTILISATEUR ===");

        // Cr√©ation du compte de tokens pour user1
        const userTokenAccount = await getOrCreateAssociatedTokenAccount(
            this.connection,
            this.user1,
            this.underlyingMint!,
            this.user1.publicKey
        );

        // Mint de tokens pour les tests
        await mintTo(
            this.connection,
            this.admin,
            this.underlyingMint!,
            userTokenAccount.address,
            this.admin,
            this.depositAmount * 3 // 3000 tokens
        );

        console.log("‚úÖ User1 a re√ßu", (this.depositAmount * 3) / 10 ** this.decimals, "tokens");
        console.log("üí∞ Compte de tokens:", userTokenAccount.address.toString());

        return userTokenAccount;
    }

    async depositToStrategy(userTokenAccount: any) {
        console.log("\nüîÑ === D√âP√îT DANS LA STRAT√âGIE YIELDOS ===");

        try {
            // Cr√©ation du compte de yield tokens
            const userYieldTokenAccount = await getOrCreateAssociatedTokenAccount(
                this.connection,
                this.user1,
                this.yieldTokenMintPda!,
                this.user1.publicKey
            );

            const tx = await this.program.methods
                .depositToStrategy(new anchor.BN(this.depositAmount), new anchor.BN(this.strategyId))
                .accounts({
                    user: this.user1.publicKey,
                    strategy: this.strategyPda,
                    userPosition: this.userPositionPda,
                    underlyingTokenMint: this.underlyingMint,
                    userUnderlyingToken: userTokenAccount.address,
                    strategyVault: this.strategyVaultPda,
                    yieldTokenMint: this.yieldTokenMintPda,
                    userYieldTokenAccount: userYieldTokenAccount.address,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
                    systemProgram: SystemProgram.programId,
                    rent: SYSVAR_RENT_PUBKEY,
                } as any)
                .signers([this.user1])
                .rpc();

            console.log("‚úÖ D√©p√¥t effectu√© avec succ√®s!");
            console.log("üìù Transaction:", tx);
            console.log("üí∞ Montant d√©pos√©:", this.depositAmount / 10 ** this.decimals, "tokens");

            // V√©rification
            const userPosition = await this.program.account.userPosition.fetch(this.userPositionPda!);
            const strategy = await this.program.account.strategy.fetch(this.strategyPda!);

            console.log("üìä Position utilisateur:");
            console.log("   üí∞ Montant d√©pos√©:", userPosition.depositedAmount.toNumber() / 10 ** this.decimals);
            console.log("   ü™ô Yield tokens mint√©s:", userPosition.yieldTokensMinted.toNumber() / 10 ** this.decimals);

            console.log("üìä Strat√©gie mise √† jour:");
            console.log("   üí∞ D√©p√¥ts totaux:", strategy.totalDeposits.toNumber() / 10 ** this.decimals);
            console.log("   ü™ô Yield tokens totaux:", strategy.totalYieldTokensMinted.toNumber() / 10 ** this.decimals);

        } catch (error: any) {
            console.error("‚ùå Erreur de d√©p√¥t:", error.message);
            throw error;
        }
    }

    async claimYield() {
        console.log("\nüîÑ === R√âCLAMATION DU YIELD ===");

        try {
            // Attendre un peu pour que le yield s'accumule
            console.log("‚è≥ Attente pour accumulation du yield...");
            await new Promise(resolve => setTimeout(resolve, 3000));

            const userYieldTokenAccount = await getOrCreateAssociatedTokenAccount(
                this.connection,
                this.user1,
                this.yieldTokenMintPda!,
                this.user1.publicKey
            );

            const initialBalance = Number(userYieldTokenAccount.amount);
            console.log("üí∞ Balance initiale de yield tokens:", initialBalance / 10 ** this.decimals);

            const tx = await this.program.methods
                .claimYield(new anchor.BN(this.strategyId))
                .accounts({
                    user: this.user1.publicKey,
                    strategy: this.strategyPda,
                    userPosition: this.userPositionPda,
                    yieldTokenMint: this.yieldTokenMintPda,
                    userYieldTokenAccount: userYieldTokenAccount.address,
                    tokenProgram: TOKEN_PROGRAM_ID,
                } as any)
                .signers([this.user1])
                .rpc();

            console.log("‚úÖ Yield r√©clam√©!");
            console.log("üìù Transaction:", tx);

            // V√©rification
            const finalTokenAccount = await getOrCreateAssociatedTokenAccount(
                this.connection,
                this.user1,
                this.yieldTokenMintPda!,
                this.user1.publicKey
            );

            const finalBalance = Number(finalTokenAccount.amount);
            const yieldEarned = (finalBalance - initialBalance) / 10 ** this.decimals;

            console.log("üí∞ Balance finale de yield tokens:", finalBalance / 10 ** this.decimals);
            console.log("üìà Yield gagn√©:", yieldEarned);

        } catch (error: any) {
            console.error("‚ùå Erreur de r√©clamation:", error.message);
            throw error;
        }
    }

    async createMarketplace() {
        console.log("\nüîÑ === CR√âATION DU MARKETPLACE YIELDOS ===");

        try {
            const tradingFeeBps = 100; // 1%
            const marketplaceId = 0;

            const tx = await this.program.methods
                .createMarketplace(
                    new anchor.BN(this.strategyId),
                    new anchor.BN(marketplaceId),
                    tradingFeeBps
                )
                .accounts({
                    admin: this.admin.publicKey,
                    strategy: this.strategyPda,
                    marketplace: this.marketplacePda,
                    marketplaceCounter: this.marketplaceCounterPda,
                    systemProgram: SystemProgram.programId,
                    rent: SYSVAR_RENT_PUBKEY,
                } as any)
                .signers([this.admin])
                .rpc();

            console.log("‚úÖ Marketplace Yieldos cr√©√©!");
            console.log("üìù Transaction:", tx);

            // V√©rification
            const marketplace = await this.program.account.marketplace.fetch(this.marketplacePda!);
            console.log("üìä D√©tails du marketplace:");
            console.log("   üè™ Strategy:", marketplace.strategy.toString());
            console.log("   üí∞ Frais de trading:", marketplace.tradingFeeBps / 100, "%");
            console.log("   ‚úÖ Actif:", marketplace.isActive);
            console.log("   üìä Volume total:", marketplace.totalVolume.toNumber());
            console.log("   üîÑ Trades totaux:", marketplace.totalTrades.toNumber());

        } catch (error: any) {
            if (error.message.includes("already in use")) {
                console.log("‚ÑπÔ∏è  Marketplace d√©j√† cr√©√©");
            } else {
                console.error("‚ùå Erreur de cr√©ation du marketplace:", error.message);
                throw error;
            }
        }
    }

    async displaySummary() {
        console.log("\nüìä === R√âSUM√â FINAL YIELDOS ===");
        console.log("=====================================");

        try {
            const strategy = await this.program.account.strategy.fetch(this.strategyPda!);
            const userPosition = await this.program.account.userPosition.fetch(this.userPositionPda!);
            const marketplace = await this.program.account.marketplace.fetch(this.marketplacePda!);

            console.log("üèóÔ∏è  STRAT√âGIE:");
            console.log(`   üìù Nom: ${strategy.name}`);
            console.log(`   üìà APY: ${strategy.apy.toNumber() / 100}%`);
            console.log(`   üí∞ D√©p√¥ts totaux: ${strategy.totalDeposits.toNumber() / 10 ** this.decimals} tokens`);
            console.log(`   ü™ô Yield tokens mint√©s: ${strategy.totalYieldTokensMinted.toNumber() / 10 ** this.decimals}`);
            console.log("");

            console.log("üë§ POSITION UTILISATEUR:");
            console.log(`   üí∞ D√©pos√©: ${userPosition.depositedAmount.toNumber() / 10 ** this.decimals} tokens`);
            console.log(`   ü™ô Yield tokens: ${userPosition.yieldTokensMinted.toNumber() / 10 ** this.decimals}`);
            console.log(`   üìÖ Date de d√©p√¥t: ${new Date(userPosition.depositTime.toNumber() * 1000).toLocaleString()}`);
            console.log("");

            console.log("üè™ MARKETPLACE:");
            console.log(`   üí∞ Frais: ${marketplace.tradingFeeBps / 100}%`);
            console.log(`   üìä Volume: ${marketplace.totalVolume.toNumber() / 10 ** this.decimals} tokens`);
            console.log(`   üîÑ Trades: ${marketplace.totalTrades.toNumber()}`);
            console.log("");

            console.log("üéØ STATUS: YIELDOS ENTI√àREMENT FONCTIONNEL!");
            console.log("‚úÖ Toutes les fonctions ont √©t√© test√©es avec succ√®s");
            console.log("=====================================");

        } catch (error: any) {
            console.error("‚ùå Erreur lors du r√©sum√©:", error.message);
        }
    }

    async run() {
        try {
            console.log("üé¨ === D√âMO INTERACTIVE YIELDOS ===\n");

            await this.setupAccounts();
            await this.initializeProtocol();
            await this.createStrategy();

            const userTokenAccount = await this.setupUserTokens();
            await this.depositToStrategy(userTokenAccount);
            await this.claimYield();
            await this.createMarketplace();

            await this.displaySummary();

            console.log("\nüéâ === D√âMO YIELDOS TERMIN√âE AVEC SUCC√àS ===");

        } catch (error) {
            console.error("\nüí• Erreur lors de la d√©mo:", error);
            process.exit(1);
        }
    }
}

// Ex√©cution du script
async function main() {
    const demo = new YieldosInteraction();
    await demo.run();
}

main().catch(console.error); 